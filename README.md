# Binary Files Difference

Задача отборочного этапа на кафедру *1С* о вычислении разницы между бинарными файлами

## Условие задачи

Код задачи: 142

Реализуйте механизм, позволяющий хранить изменения между двумя бинарными файлами.

На вход операции "Рассчитать диф" подаются два бинарных файла ("старый" и "новый"). Операция должна оптимально сформировать файл разницы между ними.

На вход операции "Восстановить" подаётся "старый" файл и файл разницы. Она должна восстановить "новый" файл. 


"Файлы" должны храниться и создаваться на диске, хранение промежуточных данных в оперативной памяти запрещено.

## Предлагаемое решение

### В первом приближении

Начать можно с самого простого и наивного механизма --- хранения разницы между файлами побайтово.
В таком случае разность представляет собой также бинарный файл, причём её размер соответствует размеру большего из файлов.

Тут ещё нужно не забыть про ведущий байт на случай отрицательной разницы.

Рассчёт разницы и восстановление файла будут выполняться за время, пропорциональное длине файла. Такое решение очень 
нецелесообразно для небольших изменений больших файлов.

Сразу хочется найти некую оптимизацию, которая позволит не хранить все байты, а только изменённые.

### Оптимизация памяти, используемой для хранения разности небольших изменений

Не помешают обёртки над файлами [`File`](File.h).

Можно придумать, как получше хранить разности, можно унаследовать отдельный тип файла [`DifFile`](DifFile.h),
 в котором, например, будет храниться какая-то заголовочная информация, а за ней список структур
[`Diff`](Diff.h), которые будут указывать на отдельные блоки изменений в файле.

Представим, что мы работаем с файлами большого размера, в которых где-то записаны изменения,
при этом решение будет направлено на случай, когда длина изменений не очень большая. Если применить
ситуацию к редактированию текстового документа, то в типичном случае это, например, добавление крупных блоков в конец,
которые неизбежно придётся хранить в файле с разницей, или небольшие изменения где-то в теле документа,
которые будет удобно хранить с указателем на место.

Можно придумать много способов локализовать блоки, рассмотрим самый примитивный вариант, в силу нехватки времени АААААААААААААААА.

Будем идти вдоль двух файлов и сравнивать символы. Встретив различающийся байт, создаём новую структуру [`File`](File.h)
и сразу положим в неё указатель на текущую позицию в старом файле (для восстановления). Открылся блок изменения, записываем 
в него подряд несовпадающие символы, пока не встретим `a` совпадающих, где `а` --- некоторый параметр, определяющий ширину 
блока с изменениями. Для разных типов изменений его можно подстраивать под текущую задачу.

Такое решение пока не умеет определять сдвиги, например, если в начало файла был добавлен один байт, 
он перепишет файл полностью. Также оно неустойчиво к очень большим файлам, где число, определяющее позицию в файле может
переполниться, но больший файлы обычно разбиваются на удобные файлы поменьше.

### Идеи для дальнейших оптимизаций

Используя алгоритмы на строках, наверняка можно добавить много хорошего в решение этой задачи.
Может пригодиться расстояние Левенштейна, особенно если изменения нужно записывать последовательно в процессе 
редактирования.
Не стоит забывать о замечательных алгоритмах поиска больших общих подстрок, например, если файлы значительно отличаются,
стоит поискать общие подстроки и облегчить себе задачу до разности остальных частей файла.

## А что в результате четырёхчасовой работы?

Общий план проекта, код примитивного решения. Я честно могу лучше, но не сейчас и не за такое время(.